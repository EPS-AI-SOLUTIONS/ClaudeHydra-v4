/**
 * ClaudeChatView — Full chat interface for Claude API with NDJSON streaming.
 *
 * Supports agentic tool_use loop: when tools are enabled, Claude can invoke
 * local file tools (read, list, write, search) and results are displayed
 * inline as collapsible ToolCallBlock panels.
 */

import { useVirtualizer } from '@tanstack/react-virtual';
import { ArrowDown, MessageSquare } from 'lucide-react';
import { AnimatePresence, motion } from 'motion/react';
import { useCallback, useEffect, useMemo, useRef, useState } from 'react';
import { useTranslation } from 'react-i18next';
import { EmptyState } from '@/components/molecules/EmptyState';
import type { ModelOption } from '@/components/molecules/ModelSelector';
import { useAutoScroll } from '@/features/chat/hooks/useAutoScroll';
import { type ClaudeModel, FALLBACK_CLAUDE_MODELS, useClaudeModels } from '@/features/chat/hooks/useClaudeModels';
import { useSessionSync } from '@/features/chat/hooks/useSessionSync';
import { useOnlineStatus } from '@/shared/hooks/useOnlineStatus';
import { useSettingsQuery } from '@/shared/hooks/useSettings';
import { cn } from '@/shared/utils/cn';
import { useViewStore } from '@/stores/viewStore';
import { claudeHealthCheck, DEFAULT_MODEL } from '../api/claudeStream';
import { useChatMessages } from '../hooks/useChatMessages';
import { useChatStreaming } from '../hooks/useChatStreaming';
import { usePromptHistory } from '../hooks/usePromptHistory';
import { ChatHeader } from './ChatHeader';
import { ChatInput } from './ChatInput';
import { type ChatMessage, MessageBubble } from './MessageBubble';
import { SearchOverlay } from './SearchOverlay';

// ---------------------------------------------------------------------------
// Model option adapter
// ---------------------------------------------------------------------------

function toModelOption(m: ClaudeModel): ModelOption {
  return {
    id: m.id,
    name: m.name,
    provider: m.provider,
    available: m.available,
    description: m.tier,
  };
}

// ---------------------------------------------------------------------------
// Empty state sub-component (uses shared EmptyState molecule)
// ---------------------------------------------------------------------------

function EmptyChatState() {
  const { t } = useTranslation();
  return (
    <motion.div
      initial={{ opacity: 0, y: 10 }}
      animate={{ opacity: 1, y: 0 }}
      transition={{ delay: 0.15 }}
      data-testid="chat-empty-state"
      className="h-full flex items-center justify-center"
    >
      <EmptyState
        icon={MessageSquare}
        title={t('chat.startConversation', 'Start a new conversation')}
        description={t(
          'chat.selectModelAndType',
          'Select a model and type a message. Drag and drop files to add context.',
        )}
      />
    </motion.div>
  );
}

// ---------------------------------------------------------------------------
// #1 — Virtualized message area sub-component
// Uses @tanstack/react-virtual for efficient rendering of long conversations.
// ---------------------------------------------------------------------------

interface VirtualizedMessageAreaProps {
  messages: ChatMessage[];
  welcomeMessage?: string;
  setChatRef: (el: HTMLDivElement | null) => void;
  bottomRef: React.RefObject<HTMLDivElement | null>;
  messagesEndRef: React.RefObject<HTMLDivElement | null>;
  searchOpen: boolean;
  searchMatchId: string | null;
  onSearchMatchChange: (messageId: string | null) => void;
  onSearchClose: () => void;
  showNewMessages: boolean;
  scrollToBottom: () => void;
}

function VirtualizedMessageArea({
  messages,
  welcomeMessage,
  setChatRef,
  bottomRef,
  messagesEndRef,
  searchOpen,
  searchMatchId,
  onSearchMatchChange,
  onSearchClose,
  showNewMessages,
  scrollToBottom,
}: VirtualizedMessageAreaProps) {
  const { t } = useTranslation();
  const parentRef = useRef<HTMLDivElement>(null);
  const prevCountRef = useRef(messages.length);

  // Merge parent ref with external setChatRef
  const setParentRef = useCallback(
    (el: HTMLDivElement | null) => {
      (parentRef as React.MutableRefObject<HTMLDivElement | null>).current = el;
      setChatRef(el);
    },
    [setChatRef],
  );

  const virtualizer = useVirtualizer({
    count: messages.length,
    getScrollElement: () => parentRef.current,
    estimateSize: () => 120,
    overscan: 5,
    getItemKey: (index) => messages[index]?.id ?? index,
  });

  // Auto-scroll to bottom when new messages arrive
  useEffect(() => {
    if (messages.length > prevCountRef.current && messages.length > 0) {
      // Scroll to the last item
      virtualizer.scrollToIndex(messages.length - 1, { align: 'end', behavior: 'smooth' });
    }
    prevCountRef.current = messages.length;
  }, [messages.length, virtualizer]);

  // Also scroll when the last message is streaming (content changing)
  const lastMessage = messages[messages.length - 1];
  const isLastStreaming = lastMessage?.streaming;
  // biome-ignore lint/correctness/useExhaustiveDependencies: lastMessage?.content.length is intentional — triggers scroll on each streaming token
  useEffect(() => {
    if (isLastStreaming && messages.length > 0) {
      virtualizer.scrollToIndex(messages.length - 1, { align: 'end' });
    }
  }, [isLastStreaming, lastMessage?.content.length, messages.length, virtualizer]);

  // Empty state / welcome message
  if (messages.length === 0) {
    return (
      <div
        ref={setParentRef}
        data-testid="chat-message-area"
        role="log"
        aria-live="polite"
        aria-label={t('chat.messageArea', 'Chat messages')}
        className={cn('flex-1 p-4 overflow-y-auto relative transition-all rounded-lg', 'scrollbar-thin')}
      >
        <AnimatePresence>
          {searchOpen && (
            <SearchOverlay messages={messages} onMatchChange={onSearchMatchChange} onClose={onSearchClose} />
          )}
        </AnimatePresence>
        {welcomeMessage ? (
          <div className="space-y-4">
            <MessageBubble
              message={{
                id: 'welcome',
                role: 'assistant',
                content: welcomeMessage,
                timestamp: new Date(),
              }}
            />
          </div>
        ) : (
          <EmptyChatState />
        )}
      </div>
    );
  }

  return (
    <div
      ref={setParentRef}
      data-testid="chat-message-area"
      role="log"
      aria-live="polite"
      aria-label={t('chat.messageArea', 'Chat messages')}
      className={cn('flex-1 p-4 overflow-y-auto relative transition-all rounded-lg', 'scrollbar-thin')}
    >
      {/* #19 — Search overlay */}
      <AnimatePresence>
        {searchOpen && (
          <SearchOverlay messages={messages} onMatchChange={onSearchMatchChange} onClose={onSearchClose} />
        )}
      </AnimatePresence>

      {/* Virtualized message list */}
      <div
        style={{
          height: virtualizer.getTotalSize(),
          width: '100%',
          position: 'relative',
        }}
      >
        {virtualizer.getVirtualItems().map((virtualRow) => {
          const msg = messages[virtualRow.index];
          if (!msg) return null;
          return (
            <div
              key={virtualRow.key}
              data-index={virtualRow.index}
              data-message-id={msg.id}
              ref={virtualizer.measureElement}
              style={{
                position: 'absolute',
                top: 0,
                left: 0,
                width: '100%',
                transform: `translateY(${virtualRow.start}px)`,
              }}
            >
              <div className="pb-4">
                <MessageBubble
                  message={msg}
                  className={searchMatchId === msg.id ? 'ring-2 ring-yellow-400/60 rounded-xl' : undefined}
                />
              </div>
            </div>
          );
        })}
      </div>
      <div ref={bottomRef} />
      <div ref={messagesEndRef} />

      {/* #20 — New messages floating button */}
      <AnimatePresence>
        {showNewMessages && (
          <motion.button
            type="button"
            initial={{ opacity: 0, y: 10 }}
            animate={{ opacity: 1, y: 0 }}
            exit={{ opacity: 0, y: 10 }}
            onClick={scrollToBottom}
            className="sticky bottom-2 left-1/2 -translate-x-1/2 z-20 flex items-center gap-1.5 px-4 py-2 rounded-full bg-[var(--matrix-accent)] text-[var(--matrix-bg-primary)] text-sm font-mono shadow-lg hover:shadow-xl transition-shadow"
            aria-label={t('chat.newMessages', 'New messages, scroll to bottom')}
          >
            <ArrowDown size={14} />
            {t('chat.newMessages', 'New messages')}
          </motion.button>
        )}
      </AnimatePresence>
    </div>
  );
}

// ---------------------------------------------------------------------------
// ClaudeChatView component
// ---------------------------------------------------------------------------

export function ClaudeChatView() {
  const { t } = useTranslation();

  // Dynamic model registry (falls back to hardcoded list)
  const { data: claudeModels } = useClaudeModels();
  const models = claudeModels ?? FALLBACK_CLAUDE_MODELS;

  // Model state
  const [selectedModel, setSelectedModel] = useState<string>(DEFAULT_MODEL);
  const [claudeConnected, setClaudeConnected] = useState(false);

  // Tools toggle
  const [toolsEnabled, setToolsEnabled] = useState(true);

  // Per-session message state (extracted hook)
  const messageState = useChatMessages();
  const { messages, isLoading, clearChat } = messageState;

  // DB sync
  const { addMessageWithSync, renameSessionWithSync, generateTitleWithSync } = useSessionSync();
  const activeSessionId = useViewStore((s) => s.activeSessionId);
  const activeSession = useViewStore((s) => s.chatSessions.find((cs) => cs.id === s.activeSessionId));
  const setSessionWorkingDirectory = useViewStore((s) => s.setSessionWorkingDirectory);

  // Settings (for welcome message)
  const { data: settings } = useSettingsQuery();

  // #25 — Offline detection
  const isOnline = useOnlineStatus();

  // #19 — Message search (Ctrl+F)
  const [searchOpen, setSearchOpen] = useState(false);
  const [searchMatchId, setSearchMatchId] = useState<string | null>(null);

  // Refs
  const messagesEndRef = useRef<HTMLDivElement>(null);
  const chatContainerRef = useRef<HTMLDivElement>(null);

  // #20 — Auto-scroll indicator
  const { containerRef: autoScrollRef, bottomRef, showNewMessages, scrollToBottom } = useAutoScroll(messages.length);

  // Merge container refs
  const setChatRef = useCallback(
    (el: HTMLDivElement | null) => {
      (chatContainerRef as React.MutableRefObject<HTMLDivElement | null>).current = el;
      (autoScrollRef as React.MutableRefObject<HTMLDivElement | null>).current = el;
    },
    [autoScrollRef],
  );

  // ----- Check Claude API connectivity on mount ----------------------------

  useEffect(() => {
    void claudeHealthCheck().then(setClaudeConnected);
  }, []);

  // ----- Ctrl+F search overlay (#19) ----------------------------------------
  useEffect(() => {
    const handler = (e: KeyboardEvent) => {
      if ((e.ctrlKey || e.metaKey) && e.key === 'f') {
        e.preventDefault();
        setSearchOpen((prev) => !prev);
      }
    };
    window.addEventListener('keydown', handler);
    return () => window.removeEventListener('keydown', handler);
  }, []);

  const handleSearchMatchChange = useCallback((messageId: string | null) => {
    setSearchMatchId(messageId);
    if (messageId) {
      const el = document.querySelector(`[data-message-id="${messageId}"]`);
      el?.scrollIntoView({ behavior: 'smooth', block: 'center' });
    }
  }, []);

  // ----- Model selection adapter -------------------------------------------

  const modelOptions = useMemo(() => models.map(toModelOption), [models]);

  const handleModelSelect = useCallback((model: ModelOption) => {
    setSelectedModel(model.id);
  }, []);

  // ----- Tools toggle handler (stable ref for ChatHeader) ------------------

  const handleToolsToggle = useCallback(() => {
    setToolsEnabled((v) => !v);
  }, []);

  // ----- Per-session working directory -------------------------------------

  const handleWorkingDirectoryChange = useCallback(
    (wd: string) => {
      if (activeSessionId) {
        setSessionWorkingDirectory(activeSessionId, wd);
      }
    },
    [activeSessionId, setSessionWorkingDirectory],
  );

  // ----- Prompt history for arrow-key navigation (global, SQL-backed) ------

  const { promptHistory, addPrompt } = usePromptHistory();

  // ----- Streaming hook (extracted from inline handleSend) -----------------

  const { handleSend } = useChatStreaming({
    selectedModel,
    toolsEnabled,
    messageState,
    addMessageWithSync,
    renameSessionWithSync,
    generateTitleWithSync,
    addPrompt,
  });

  // ----- Render -------------------------------------------------------------

  return (
    <div data-testid="chat-view" className="h-full flex flex-col p-4">
      {/* Header */}
      <ChatHeader
        claudeConnected={claudeConnected}
        modelCount={models.length}
        modelOptions={modelOptions}
        selectedModel={selectedModel || null}
        onModelSelect={handleModelSelect}
        toolsEnabled={toolsEnabled}
        onToolsToggle={handleToolsToggle}
        messages={messages}
        activeSessionTitle={activeSession?.title}
        activeSessionCreatedAt={activeSession?.createdAt}
        onClearChat={clearChat}
      />

      {/* #1 Virtualized message area */}
      <VirtualizedMessageArea
        messages={messages}
        welcomeMessage={settings?.welcome_message}
        setChatRef={setChatRef}
        bottomRef={bottomRef}
        messagesEndRef={messagesEndRef}
        searchOpen={searchOpen}
        searchMatchId={searchMatchId}
        onSearchMatchChange={handleSearchMatchChange}
        onSearchClose={() => {
          setSearchOpen(false);
          setSearchMatchId(null);
        }}
        showNewMessages={showNewMessages}
        scrollToBottom={scrollToBottom}
      />

      {/* Streaming indicator bar */}
      {isLoading && (
        <motion.div
          data-testid="chat-streaming-bar"
          initial={{ scaleX: 0 }}
          animate={{ scaleX: 1 }}
          className="h-0.5 bg-gradient-to-r from-transparent via-[var(--matrix-accent)] to-transparent origin-left mt-1 rounded-full"
        />
      )}

      {/* Chat input — #25 disabled when offline */}
      <div className="mt-3">
        <ChatInput
          onSend={handleSend}
          disabled={!claudeConnected || !selectedModel || !isOnline}
          isLoading={isLoading}
          placeholder={
            !isOnline
              ? t('chat.offlinePlaceholder', 'You are offline')
              : claudeConnected
                ? 'Type a message... (Shift+Enter = new line)'
                : 'Configure API key in Settings'
          }
          promptHistory={promptHistory}
          sessionId={activeSessionId ?? undefined}
          workingDirectory={activeSession?.workingDirectory}
          onWorkingDirectoryChange={handleWorkingDirectoryChange}
        />
      </div>
    </div>
  );
}

export default ClaudeChatView;
